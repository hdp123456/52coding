
# MySQL规范
2019年05月20日 14:30:00 胡文亮
## 一.MySQL使用规范
### 1. 基础规范
   * 使用INNODB存储引擎
   * 表字符集使用UTF8编码(如果存储emoji 则使用utf8bm4)
   * 单表数据量建议控制在<label style="color:red">5000W</label>以内
   * 数据库禁止存储图 、文件等大数据文件，如果确实需要，可用MongoDB或ES等其他解决方案
   * 禁止在线上环境做数据库压力测试、以及开发环境直连线上数据库
   
### 2. 命名规范
   * 库名、表名、字段名、索引名全部小写。加上下划线'_'组成
   * <label style="color:red">表名最多三个单词，字段最多两个单词</label>
   * <label style="color:red">库名、表名、字段名禁止使用MySQL保留字</label>([保留字](https://www.cnblogs.com/duanxz/p/5099989.html))
   * 库名、表名、字段名禁止超过32个字符。须见名知意
   * <label style="color:red">临时库、表名必须以tmp 为前缀，并以日期为后缀</label>
   
### 3. 库、表、字段开发设计规范
   * 每张表必须有注释、字段必须有注释
   * 根据字段含义，合理设置字段长度
   * 表设计遵循三范式设计原则
   * 所有表采用自增主键
   * <label style="color:red">所有字段均定义为NOT NULL，不可为空且必须设置默认值</label>
   * <label style="color:red">使用 DATETIME 存储日期时间。默认值 CURRENT_TIMESTAMP</label>
   * <label style="color:red">使用 DATE 存储日期。默认值 '1970-01-01'</label>
   * <label style="color:red">使用 TIME 存储时间。默认值 '00:00:00'</label>
   * 每张表均需有创建时间、更新时间
   * 能用一条SQL查询尽量使用一条SQL，禁止在for循环中使用SQL查询
   * 建表注意建立合适的索引 切勿忘记
   
   
## 二.MySQL数据库设计原则
###  1. 核心原则
   * 不在数据库做运算，cpu 计算务必移至业务层
   * 控制列数量(字段少而精,字段数建议在 20 以内)
   * <label style="color:red">平衡范式与冗余(效率优先；往往牺牲范式)</label>
   * 拒绝 3B(拒绝大 sql 语句：big sql、拒绝大事物：big transaction、拒绝大批量：big batch)
   
###  2. 字段类原则
   * 用好数值类型(用合适的字段类型节约空间)
   * 字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能)
   * 避免使用 NULL 字段(NULL 字段很难查询优化、NULL 字段的索引需要额外空间、NULL 字段的复合索引无效)
   * 少用 text 类型(尽量使用 varchar 代替 text 字段)
   
###  3. 索引类原则
  * 合理使用索引(改善查询,减慢更新,索引一定不是越多越好)
  * 字符字段必须建前缀索引
  * 不在索引做列运算
  * innodb 主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)
  * 不用外键(由程序保证约束)
  * 单张表中索引数量不超过5个单个索引中的字段数不超过5个
  * 对字符串使用前缀索引，前缀索引长度不超过8个字符
  * 建议优先考虑前缀索引，必要时可添加伪列并建立索引
  
###  4. SQL使用规则及优化 
   * sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库)
   * 简单的事务,避免使用 trig/func(触发器、函数不用客户端程序取而代之)
   * 不用 select*(消耗 cpu,io,内存,带宽,这种程序不具有扩展性)
   * OR 改写为 IN(or 的效率是 n 级别)
   * 慎用 count(*)
   * Limit 高效分页(limit 越大，效率越低)
   * 使用union all 替代 union(union 有去重开销)
   * 少用连接 join
   * 使用 group by,请使用同类型比较,打散批量更新
   
###  5. 性能分析工具 Explain
   * <label style="color:red">explain 显示了 mysql 如何使用索引来处理 select 语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句</label>
   * 使用方法，在 select 语句前加上 explain 就可以了
   * 如：【explain select surname,first_name form a,b where a.id=b.id】

### 6. EXPLAIN 列的解释：
   * table：显示这一行的数据是关于哪张表的
   * type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为 const、eq_reg、ref、range、index 和 ALL
   * possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从 WHERE 语句中选择一个合适的语句
   * key：实际使用的索引。如果为 NULL，则没有使用索引。很少的情况下，MYSQL 会选择优化不足的索引。这种情况下，可以在 SELECT 语句中使用 USE INDEX（indexname）来强制使用一个索引或者
   * 用IGNORE INDEX（indexname）来强制 MYSQL 忽略索引
      * key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好
      * ref：显示索引的哪一列被使用了，如果可能的话，是一个常数rows：
      * MYSQL 认为必须检查的用来返回请求数据的行数
      * Extra：关于 MYSQL 如何解析查询的额外信息。将在表 4.3 中讨论，但这里可以看到的坏的例子是 Using temporary 和 Using filesort，意思 MYSQL 根本不能使用索引，结果是检索会很慢
          
### 7. EXPLAIN 列返回的描述的意义：
  * Distinct:一旦 MYSQL 找到了与行相联合匹配的行，就不再搜索了
  * Not exists: MYSQL 优化了 LEFT JOIN，一旦它找到了匹配 LEFT JOIN 标准的行，就不再搜索了
  * Range checked for each Record（index map:#）:没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL 检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
  * <b>Using file sort</b>: 看到这个的时候，查询就需要优化了。MYSQL 需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行
  * Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候  
  * Using temporary 看到这个的时候，查询需要优化了。这里，MySQL 需要创建一个临时表来存储结果，这通常发生在对不同的列集进行 ORDER BY 上，而不是 GROUP BY 上
  * Where used 使用了 WHERE 从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型 ALL 或 index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）
  * system 表只有一行：system 表。这是 const 连接类型的特殊情况
  * const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为 MYSQL 先读这个值然后把它当做常数来对待
  * eq_ref:在连接中，MYSQL 在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用
  * ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好
  * range:这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况
  * index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比 ALL 更好，因为索引一般小于表数据）
       
## 三.数据库三段式
### 1.三范式介绍  
  * 基本表及其字段之间的关系, 应尽量满足第三范式。但是，满足第三范式的数据库设计，往往不是最好的设计，为了提高数据库的运行效率，常常需要降低范式标准：适当增加冗余，达到以空间换时间的目的
  * 第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性
  * 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要 求数据库表中的每个实例或行必须可以被惟一地区分。
  * 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息
    
    
    
             

  